diff -uNr NVIDIA-Linux-x86-1.0-5336-pkg1/usr/src/nv/nv.c NVIDIA-Linux-x86-1.0-5336-pkg1.fixed/usr/src/nv/nv.c
--- NVIDIA-Linux-x86-1.0-5336-pkg1/usr/src/nv/nv.c	2004-01-15 04:29:11.000000000 +0100
+++ NVIDIA-Linux-x86-1.0-5336-pkg1.fixed/usr/src/nv/nv.c	2004-02-17 20:53:36.000000000 +0100
@@ -1103,7 +1103,7 @@
  * addresses by the CPU.  This nopage handler will fault on CPU
  * accesses to AGP memory and map the address to the correct page.
  */
-struct page *nv_kern_vma_nopage(struct vm_area_struct *vma, unsigned long address, int write_access)
+struct page *nv_kern_vma_nopage(struct vm_area_struct *vma, unsigned long address, int *write_access)
 {
 #if defined(NVCPU_IA64) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 9))
     nv_alloc_t *at, *tmp;
@@ -1183,6 +1183,7 @@
     nv_kern_vma_open,
     nv_kern_vma_release,  /* "close" */
     nv_kern_vma_nopage,
+    0
 };
 
 static nv_file_private_t *
@@ -2558,7 +2559,7 @@
              * so use the first page, which is page-aligned. this way, our 
              * allocated page table does not need to be page-aligned
              */
-            *pAddress = (void *) at->page_table[0].dma_addr;
+            *pAddress = (void *)(NV_UINTPTR_T) at->page_table[0].dma_addr;
             at->flags = NV_ALLOC_TYPE_PCI;
             nvl_add_alloc(nvl, at);
         } else
diff -uNr NVIDIA-Linux-x86-1.0-5336-pkg1/usr/src/nv/nv-linux.h NVIDIA-Linux-x86-1.0-5336-pkg1.fixed/usr/src/nv/nv-linux.h
--- NVIDIA-Linux-x86-1.0-5336-pkg1/usr/src/nv/nv-linux.h	2004-01-15 04:29:11.000000000 +0100
+++ NVIDIA-Linux-x86-1.0-5336-pkg1.fixed/usr/src/nv/nv-linux.h	2004-02-17 20:57:55.438110888 +0100
@@ -143,7 +143,7 @@
     }
 #define NV_MEM_TRACKING_RETRIEVE_SIZE(ptr, size) \
     { \
-        (char *) (ptr) -= sizeof(void *); \
+        ptr -= sizeof(void *); \
         size = *(int *) (ptr); \
     }
 #else
@@ -293,13 +293,13 @@
 #if defined(NVCPU_IA64)
 #define NV_VMALLOC(ptr, size) \
     { \
-        (void *) (ptr) = vmalloc_dma(size); \
+        ptr = vmalloc_dma(size); \
         VM_ALLOC_RECORD(ptr, size, "vm_alloc"); \
     }
 #else
 #define NV_VMALLOC(ptr, size) \
     { \
-        (void *) (ptr) = vmalloc_32(size); \
+        ptr = vmalloc_32(size); \
         VM_ALLOC_RECORD(ptr, size, "vm_alloc"); \
     }
 #endif
@@ -312,13 +312,13 @@
 
 #define NV_IOREMAP(ptr, physaddr, size) \
     { \
-        (void *) (ptr) = ioremap(physaddr, size); \
+        ptr = ioremap(physaddr, size); \
         VM_ALLOC_RECORD(ptr, size, "vm_ioremap"); \
     }
 
 #define NV_IOREMAP_NOCACHE(ptr, physaddr, size) \
     { \
-        (void *) (ptr) = ioremap_nocache(physaddr, size); \
+        ptr = ioremap_nocache(physaddr, size); \
         VM_ALLOC_RECORD(ptr, size, "vm_ioremap_nocache"); \
     }
 
@@ -333,13 +333,13 @@
  */
 #define NV_KMALLOC(ptr, size) \
     { \
-        (void *) (ptr) = kmalloc(size, GFP_KERNEL); \
+        ptr = kmalloc(size, GFP_KERNEL); \
         KM_ALLOC_RECORD(ptr, size, "km_alloc"); \
     }
 
 #define NV_KMALLOC_ATOMIC(ptr, size) \
     { \
-        (void *) (ptr) = kmalloc(size, GFP_ATOMIC); \
+        ptr = kmalloc(size, GFP_ATOMIC); \
         KM_ALLOC_RECORD(ptr, size, "km_alloc_atomic"); \
     }  
 
@@ -352,7 +352,7 @@
 
 #define NV_GET_FREE_PAGES(ptr, order) \
     { \
-        (void *) (ptr) = __get_free_pages(NV_GFP_HW, order); \
+        ptr = __get_free_pages(NV_GFP_HW, order); \
     }
         
 #define NV_FREE_PAGES(ptr, order) \
@@ -690,7 +690,7 @@
 
 /* for the card devices */
 #define NVL_FROM_FILEP(filep) \
-    ((nv_linux_state_t*) (NV_GET_NVFP(filep))->nvptr)
+    ((NV_GET_NVFP(filep))->nvptr)
 
 #define NV_GET_NVL_FROM_NV_STATE(nv) \
     ((nv_linux_state_t *) nv->os_state)
